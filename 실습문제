SELECT* FROM EMPLOYEES;
SELECT* FROM DEPARTMENTS;
SELECT* FROM LOCATIONS;
SELECT* FROM COUNTRIES;
SELECT* FROM REGIONS;
SELECT* FROM JOB_HISTORY;
SELECT* FROM JOBS;


--hr 문제

--01. 사원의 FULL_NAME(FIRST_NAME + LAST_NAME) 과 이메일을 출력하라. 00
--(이메일@HR.COM 으로 출력하라.) 
--   concat(column1|expression2,column1|expression2)  or || 사용가능. 
SELECT FIRST_NAME || ' ' || LAST_NAME, EMAIL || '@HR.COM'
FROM EMPLOYEES;

SELECT FIRST_NAME || ' '|| LAST_NAME, CONCAT(EMAIL, '@HR.COM')
FROM EMPLOYEES;
--02. 06년 이후에 입사한 사원의 이름(FIRST_NAME) 과 사원번호 (EMPLOYEE_ID)를 출력하라. 0 0
SELECT FIRST_NAME, EMPLOYEE_ID
FROM EMPLOYEES
WHERE HIRE_DATE >= '2006-01-01';



--03. 사원의 이름(FIRST), 부서이름(DEPARTMENT_NAME), 부서가 있는 거리(STREET_ADDRESS), 부서가 있는 나라(COUNTRY_NAME) 를 출력하라.  
--다시 푼 것. --답 맞음. 
SELECT FIRST_NAME, DEPARTMENT_NAME,  STREET_ADDRESS, COUNTRY_NAME
FROM EMPLOYEES 
JOIN DEPARTMENTS USING (DEPARTMENT_ID)
JOIN LOCATIONS USING (LOCATION_ID) 
JOIN COUNTRIES USING (COUNTRY_ID)

--처음에 내가 틀리게푼 것. 
SELECT FIRST_NAME, DEPARTMENT_NAME, STREET_ADDRESS, COUNTRY_NAME
FROM EMPLOYEES, DEPARTMENTS, LOCATIONS, COUNTRIES;



--04. '부서번호가 90이고, 전화번호가 515로 시작하면서, 끝자리가 4567인 사원'이 "관리하는" 사원의 사번과 이름을 출력하라.  ??x 
--다시 푼 것, 
SELECT EMPLOYEE_ID, FIRST_NAME  --사원의 사번과 일름을 출력
FROM EMPLOYEES                 --employee테이블에서 , 
WHERE MANAGER_ID = ( 
SELECT EMPLOYEE_ID       --> 조건에 만족하는 사람이 '관리하는' 이니까 , 조건에 만족하는 사람을 매니저에 대입시켜줌. 
FROM EMPLOYEES 
WHERE DEPARTMENT_ID = 90   
AND PHONE_NUMBER LIKE '515%4567' );

--내가 처음에 푼 것 , 틀림. 
SELECT EMPLOYEE_ID , FIRST_NAME || ' ' || LAST_NAME
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 90
AND PHONE_NUMBER LIKE '515.%' 
AND PHONE_NUMBER LIKE '%.4567';
-- 정답. 
SELECT EMPLOYEE_ID , FIRST_NAME 
FROM EMPLOYEES
WHERE MANAGER_ID =
(SELECT EMPLOYEE_ID
FROM EMPLOYEES WHERE DEPARTMENT_ID = 90
AND PHONE_NUMBER LIKE '515.%.4567' );
-- sbustr 이용해서풀어도 됨. 
SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
WHERE MANAGER_ID =                    --다시풀 때 여깃 = 안씀!!! 빠먹은 거 없는지 조심 !!!
( SELECT EMPLOYEE_ID 
FROM EMPLOYEES 
WHERE DEPARTMENT_ID = 90
AND SUBSTR(PHONE_NUMBER,1 ,3) = 515
AND SUBSTR(PHONE_NUMBER, -4) = 4567);


--05. 성이 B로 시작하는 사원이 속한 부서의 부서번호와, B로 시작하는 사원의 수를 출력하라.   X 0 
--내가 처음에 푼 것. 
SELECT DEPARTMENT_ID, COUNT(LAST_NAME)
FROM EMPLOYEES 
WHERE LAST_NAME LIKE 'B%'
GROUP BY DEPARTMENT_ID;
--다시  푼 것.  --답과 같음. 
--아니 그룹 바이 왜해줘???????????? 뒤에 그룹함수가 있으니까
--group by 해주는 이유: dep_id 는 30,70,80,50 인데 count(last_name)해주면, 전체 사원의 수 1개만이 존재하니까 동시에 출력될 수 없음. 
-- 따라서, dep_id 각각에 맞는 count(last_name)집계함수에 대한 값을 넣어주려고  group by 로 묶어줌. 
SELECT DEPARTMENT_ID, COUNT(LAST_NAME)  --부서의 부서번호와,  사원의 수
FROM EMPLOYEES JOIN DEPARTMENTS USING (DEPARTMENT_ID)
WHERE LAST_NAME LIKE 'B%'
GROUP BY DEPARTMENT_ID;


--05.          성이 B로 시작하는 사원이 속한 부서의 부서번호와, B로 시작하는 사원의 수를 출력하라.   X 
--06. (5번 확장) 성이 B로 시작하는 사원이 속한 부서의 부서이름, 부서의 사원의 수를 출력하라.
--다시 푼것, 
SELECT DEPARTMENT_NAME, COUNT(LAST_NAME)
FROM  EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID)
WHERE DEPARTMENT_ID IN 
( SELECT DEPARTMENT_ID 
FROM EMPLOYEES 
WHERE LAST_NAME LIKE 'B%')   --오답 : from dep 를 from emp 으로 바꿔줌. 
GROUP BY DEPARTMENT_NAME;
--오답: WHERE DEPARTMENT_NAME 으로 하면 전체 부서이름과 그 부서의 사원 숫자가 출력됨! 흠.........
--정답과 다른 부분: () 안에 department_id 로 group by 안해줬는데 정답과 같은 출력값이 나옴 : 
        --어차피 () 밖에서 같은 중복을 없애줬기 때문에 상관없음!!

--정답 
SELECT DEPARTMENT_NAME, COUNT(*)
FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID)
WHERE DEPARTMENT_ID IN
	(SELECT DEPARTMENT_ID
	FROM EMPLOYEES
	WHERE LAST_NAME LIKE 'B%'
	GROUP BY DEPARTMENT_ID)
GROUP BY DEPARTMENT_NAME


--07. IT 프로그래머(IT_PROG : JOB_ID)의 평균 월급보다 더 많은 평균월급을 받는 부서들의 직업 이름과(JOB_ID) 평균 월급을 출력하라.
--(월급을 내림차순으로 정렬하라.)
--다시 푼 것. 
SELECT JOB_ID , AVG(SALARY)
FROM EMPLOYEES                --jobs 는 연결 필요 없음!(오답) 
HAVING  AVG(SALARY) > (SELECT AVG(SALARY) FROM EMPLOYEES WHERE JOB_ID = 'IT_PROG')
GROUP BY JOB_ID
ORDER BY AVG(SALARY) DESC;
-- # (오답)여기서 it_prog 도 같이 출력되는 이유?! where salary 로 해줘서, where avg(salary) 로 해주면 포함안됨.  왜징.? 
-- it_prog 부서의 평균월급보다 더 많은 '월급' 을 받는(평균월급이아니라) 직업의id 니까 it_prog도 포함됨. 분명 평균월급보다 많이 받는 사원이 it_prog에도 있을 테니까. 
--( 오답) WHERE을 having 으로 바꿔줘야 함. 
--정답.
SELECT JOB_ID, AVG(SALARY)
FROM EMPLOYEES
HAVING AVG(SALARY) > 
	(SELECT AVG(SALARY)
	FROM EMPLOYEES
	WHERE JOB_ID = 'IT_PROG')
GROUP BY JOB_ID
ORDER BY 2 DESC;
--처음 푼 것. 
SELECT JOB_ID , AVG(SALARY)
FROM EMPLOYEES 
WHERE SALARY > ALL (SELECT AVG(SALARY) FROM JOB_HISTORY WHERE JOB_ID = 'IT_PROG')
ORDER BY SALARY DESC;


--08. 전화번호가 650.121.8009인 사원의 이름과, 사원이 속한 부서가 위치한 도시, 주소 를 출력하라.(이름 도시 주소) 0 
--내가 푼 것. 
SELECT FIRST_NAME , CITY, STREET_ADDRESS
FROM EMPLOYEES 
JOIN DEPARTMENTS USING (DEPARTMENT_ID)
JOIN LOCATIONS USING (LOCATION_ID)
WHERE PHONE_NUMBER = '650.121.8009';
--정답
SELECT FIRST_NAME, CITY, STREET_ADDRESS
FROM EMPLOYEES 
     JOIN DEPARTMENTS USING(DEPARTMENT_ID)
     JOIN LOCATIONS USING(LOCATION_ID)
WHERE PHONE_NUMBER = '650.121.8009';


--09. 캐나다에서 일하고 있는 사원의 이름과, 도시, 월급을 출력하라. 0 
--내가 다시 푼 것. using 이용. 
SELECT FIRST_NAME, CITY, SALARY
FROM EMPLOYEES 
JOIN DEPARTMENTS USING (DEPARTMENT_ID)
JOIN LOCATIONS USING (LOCATION_ID)
WHERE COUNTRY_ID = 'CA';
-- 정답 중 on이용. 
SELECT FIRST_NAME, CITY, SALARY
FROM EMPLOYEES 
JOIN DEPARTMENTS ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID
JOIN LOCATIONS ON DEPARTMENTS.LOCATION_ID = LOCATIONS.LOCATION_ID
WHERE COUNTRY_ID = 'CA';



--10. 이름이 Guy 인 사원과 같은 부서에서 일하면서, Guy와 직업(JOB_ID)이 다른 사원의 모든 것을 출력하라. 0 
--모든 것이 뭐지? 
--다시 푼 것, 
SELECT *    --모든 것이니까 * 만 치면 되는데 컬럼을 입력함..(오답!) 이외에는 다 맞음.  
FROM EMPLOYEES
WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE FIRST_NAME = 'Guy' )
AND JOB_ID != ( SELECT JOB_ID FROM EMPLOYEES WHERE FIRST_NAME ='Guy') ;
--정답
SELECT *
FROM EMPLOYEES
WHERE DEPARTMENT_ID =
	(SELECT DEPARTMENT_ID
	FROM EMPLOYEES
	WHERE FIRST_NAME = 'Guy')
AND JOB_ID !=
	(SELECT JOB_ID
	FROM EMPLOYEES
	WHERE FIRST_NAME = 'Guy');



--11. 직책이 06년 7월 24일에 변경된 사원의 이름과, 과거 직업, 현재 직업을 출력하라.
SELECT * FROM JOB_HISTORY;
SELECT * FROM JOBS;
--내가 푼 것,   힌트,  a.과거  b.현재  이용해서 풀어볼 것. 
SELECT FIRST_NAME,  A.JOB_ID , B.JOB_ID
FROM EMPLOYEES 
JOIN JOB_HISTORY USING (EMPLOYEE_ID)
JOIN JOBS USING (JOB_ID)
WHERE END_DATE = '2006/07/24'; 

-- 주의 ! 두개 출력값이 다른 이유! USING (EMPLOYEE_ID) 니까 id 가 102 인 렉스만 출력되고, 
--USING (JOB_ID) 니까 job id 인 it-prog 의 사원들 이름이 전부 출력됨. 
SELECT FIRST_NAME   --  출력값:   Lex
	FROM JOB_HISTORY JOIN EMPLOYEES USING (EMPLOYEE_ID)
	WHERE END_DATE = '06/07/24';
SELECT FIRST_NAME    --출력값 : Alexande Bruce David Valli Diana
	FROM JOB_HISTORY JOIN EMPLOYEES USING (JOB_ID)
	WHERE END_DATE = '06/07/24';   
--정답 
SELECT FIRST_NAME, 과거.JOB_ID, 현재.JOB_ID
FROM EMPLOYEES 현재,
	(SELECT EMPLOYEE_ID, JOB_ID
	FROM JOB_HISTORY
	WHERE END_DATE = '06/07/24') 과거
WHERE 현재.EMPLOYEE_ID = 과거.EMPLOYEE_ID;







SELECT FIRST_NAME, 과거.JOB_ID, 현재.JOB_ID
FROM EMPLOYEES 현재,
	(SELECT EMPLOYEE_ID, JOB_ID
	FROM JOB_HISTORY
	WHERE END_DATE = '06/07/24') 과거
WHERE 현재.EMPLOYEE_ID = 과거.EMPLOYEE_ID;

--12. 관리자가 없는 부서의 이름과 부서번호를 출력하라.

--13. 조인 키워드를 사용하지 않고, IT 부서 관리자의 성(LAST_NAME)과, 월급을 출력하라.

--14. ROWNUM을 사용하여, 관리자가 존재하는 부서의 장소 중 가장 많은 장소의 도시 이름을 출력하라.

--15. 18년도가 근속 10주년인 사원의 이름과 입사일을 출력하라.


-------답 ------------------------------------------------------------------------------------------------

SELECT * FROM EMPLOYEES;
SELECT * FROM DEPARTMENTS;
SELECT * FROM LOCATIONS;
SELECT * FROM COUNTRIES;
SELECT * FROM REGIONS;
SELECT * FROM JOB_HISTORY;
SELECT * FROM JOBS;



--01. 사원의 FULL_NAME(FIRST_NAME + LAST_NAME) 과 이메일을 출력하라.
--(이메일@HR.COM 으로 출력하라.) 

SELECT FIRST_NAME || ' ' || LAST_NAME, EMAIL || '@HR.COM'
FROM EMPLOYEES; 

SELECT CONCAT(CONCAT(FIRST_NAME, ' '), LAST_NAME), CONCAT(EMAIL, '@HR.COM')
FROM EMPLOYEES;

--02. 06년 이후에 입사한 사원의 이름(FIRST_NAME) 과 사원번호 (EMPLOYEE_ID)를 출력하라.

SELECT FIRST_NAME, EMPLOYEE_ID
FROM EMPLOYEES
WHERE HIRE_DATE >= '06/01/01';

--03. 사원의 이름(FIRST), 부서이름(DEPARTMENT_NAME), 부서가 있는 거리(STREET_ADDRESS), 
--부서가 있는 나라(COUNTRY_NAME) 를 출력하라.

SELECT FIRST_NAME, DEPARTMENT_NAME, STREET_ADDRESS, COUNTRY_NAME
FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID)
     JOIN LOCATIONS USING(LOCATION_ID)
     JOIN COUNTRIES USING(COUNTRY_ID);

SELECT E.FIRST_NAME, D.DEPARTMENT_NAME, L.STREET_ADDRESS, C.COUNTRY_NAME
FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS L, COUNTRIES C
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND D.LOCATION_ID = L.LOCATION_ID
AND L.COUNTRY_ID = C.COUNTRY_ID;

--04. '부서번호가 90이고, 전화번호가 515로 시작하면서, 끝자리가 4567인 사원'이 
--관리하는 사원의 사번과 이름을 출력하라.

SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
WHERE MANAGER_ID = 
	(SELECT EMPLOYEE_ID
	FROM EMPLOYEES
	WHERE DEPARTMENT_ID = 90
	AND PHONE_NUMBER LIKE '515.%.4567');

SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
WHERE MANAGER_ID = 
	(SELECT EMPLOYEE_ID
	FROM EMPLOYEES
	WHERE DEPARTMENT_ID = 90
	AND SUBSTR(PHONE_NUMBER, 1, 3) = 515
	AND SUBSTR(PHONE_NUMBER, -4) = 4567);

--05. 성이 B로 시작하는 사원이 속한 부서의 부서번호와, B로 시작하는 사원의 수를 출력하라.

SELECT DEPARTMENT_ID, COUNT(*)
FROM EMPLOYEES
WHERE LAST_NAME LIKE 'B%'
GROUP BY DEPARTMENT_ID;

--06. (5번 확장) 성이 B로 시작하는 사원이 속한 부서의 부서이름과 사원의 수를 출력하라.

SELECT DEPARTMENT_NAME, COUNT(*)
FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID)
WHERE DEPARTMENT_ID IN
	(SELECT DEPARTMENT_ID
	FROM EMPLOYEES
	WHERE LAST_NAME LIKE 'B%'
	GROUP BY DEPARTMENT_ID)
GROUP BY DEPARTMENT_NAME;

SELECT D.DEPARTMENT_NAME, COUNT(*)
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND D.DEPARTMENT_ID IN
	(SELECT DEPARTMENT_ID
	FROM EMPLOYEES
	WHERE LAST_NAME LIKE 'B%'
	GROUP BY DEPARTMENT_ID)
GROUP BY D.DEPARTMENT_NAME;

--07. IT 프로그래머(IT_PROG : JOB_ID)의 평균 월급보다 
--더 많은 평균월급을 받는 부서들의 직업 이름과(JOB_ID) 평균 월급을 출력하라.
--(월급을 내림차순으로 정렬하라.)

SELECT JOB_ID, AVG(SALARY)
FROM EMPLOYEES
HAVING AVG(SALARY) > 
	(SELECT AVG(SALARY)
	FROM EMPLOYEES
	WHERE JOB_ID = 'IT_PROG')
GROUP BY JOB_ID
ORDER BY 2 DESC;

--08. 전화번호가 650.121.8009인 사원의 이름과, 사원이 속한 부서가 위치한 도시, 
--주소 를 출력하라.(이름 도시 주소)

SELECT FIRST_NAME, CITY, STREET_ADDRESS
FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID)
     JOIN LOCATIONS USING(LOCATION_ID)
WHERE PHONE_NUMBER = '650.121.8009';

SELECT E.FIRST_NAME, L.CITY, L.STREET_ADDRESS
FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS L
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND D.LOCATION_ID = L.LOCATION_ID
AND E.PHONE_NUMBER = '650.121.8009';

--09. 캐나다에서 일하고 있는 사원의 이름과, 도시, 월급을 출력하라.

SELECT FIRST_NAME, CITY, SALARY
FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID)
     JOIN LOCATIONS USING(LOCATION_ID)
     JOIN COUNTRIES USING(COUNTRY_ID)
WHERE COUNTRY_NAME = 'Canada';

SELECT E.FIRST_NAME, L.CITY, E.SALARY
FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS L, COUNTRIES C 
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND D.LOCATION_ID = L.LOCATION_ID
AND L.COUNTRY_ID = C.COUNTRY_ID
AND C.COUNTRY_NAME = 'Canada';

SELECT FIRST_NAME, CITY, SALARY
FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID)
     JOIN LOCATIONS USING(LOCATION_ID)
WHERE COUNTRY_ID = 'CA';

--10. 이름이 Guy 인 사원과 같은 부서에서 일하면서, Guy와 직업(JOB_ID)이 다른 사원의 
--모든 것을 출력하라.

SELECT *
FROM EMPLOYEES
WHERE DEPARTMENT_ID =
	(SELECT DEPARTMENT_ID
	FROM EMPLOYEES
	WHERE FIRST_NAME = 'Guy')
AND JOB_ID !=
	(SELECT JOB_ID
	FROM EMPLOYEES
	WHERE FIRST_NAME = 'Guy');

--10-1. 이름이 Guy 인 사원과 같은 부서에서 일하면서, Guy와 직업(JOB_ID)도 같은 사원의 
--모든 것을 출력하라.

SELECT *
FROM EMPLOYEES
WHERE (DEPARTMENT_ID, JOB_ID) = 
	(SELECT DEPARMTENT_ID, JOB_ID
	FROM EMPLOYEES
	WHERE FIRST_NAME = 'Guy');

--11. 직책이 06년 7월 24일에 변경된 사원의 이름과, 과거 직업, 현재 직업을 출력하라.

SELECT * FROM JOB_HISTORY;

SELECT FIRST_NAME, 과거.JOB_ID, 현재.JOB_ID
FROM EMPLOYEES 현재,
	(SELECT EMPLOYEE_ID, JOB_ID
	FROM JOB_HISTORY
	WHERE END_DATE = '06/07/24') 과거
WHERE 현재.EMPLOYEE_ID = 과거.EMPLOYEE_ID;
	
--12. 관리자가 없는 부서의 이름과 부서번호를 출력하라.

SELECT DEPARTMENT_NAME, DEPARTMENT_ID
FROM DEPARTMENTS
WHERE MANAGER_ID IS NULL;

--13. 조인 키워드를 사용하지 않고, IT 부서 관리자의 성(LAST_NAME)과, 월급을 출력하라.

SELECT LAST_NAME, SALARY
FROM EMPLOYEES
WHERE EMPLOYEE_ID = 
	(SELECT MANAGER_ID
	FROM DEPARTMENTS
	WHERE DEPARTMENT_NAME = 'IT');

--14. ROWNUM을 사용하여, 관리자가 존재하는 부서의 장소 중 가장 많은 장소의 도시 이름을 출력하라.

SELECT CITY, CNT, ROWNUM
FROM
	(SELECT CITY, COUNT(*) AS CNT
	FROM DEPARTMENTS JOIN LOCATIONS USING(LOCATION_ID)
	WHERE DEPARTMENT_ID IN
		(SELECT DEPARTMENT_ID
		FROM DEPARTMENTS
		WHERE MANAGER_ID IS NOT NULL)
	GROUP BY CITY
	ORDER BY COUNT(*) DESC) A
WHERE ROWNUM = 1;

--15. 18년도가 근속 10주년인 사원의 이름과 입사일을 출력하라.

SELECT FIRST_NAME, HIRE_DATE
FROM EMPLOYEES
WHERE SUBSTR(ADD_MONTHS(HIRE_DATE, 120), 1, 2) = 18;

SELECT FIRST_NAME, HIRE_DATE
FROM EMPLOYEES
WHERE FLOOR(MONTHS_BETWEEN(TO_DATE('2018-12-31','YYYY-MM-DD'),HIRE_DATE)/12) = 10;

SELECT FIRST_NAME, HIRE_DATE
FROM EMPLOYEES
WHERE MONTHS_BETWEEN('2018-12-31', HIRE_DATE) < 132;

WHERE HIRE_DATE >='08/01/01' AND HIRE_DATE <='08/12/31';

WHERE '18' - substr(hire_date,1,2) = 10


